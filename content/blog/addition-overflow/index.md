---
title: 加算結果がオーバーフローしないかの確認方法
date: "2023-08-25 11:00"
description: "応用情報の勉強メモです。令和3年秋問8で加算結果がオーバーフローしない条件を選択する問題。色々忘れていることが多いのでメモ。応用情報の勉強している方に役立ちそうな内容です。"
---

[令和3年秋問8](https://www.ap-siken.com/kakomon/03_aki/q8.html)について参照。

## 符号付きの二進数がとる整数の範囲

-128 〜 127のように、何故範囲が半端なのかがなかなか分かりにくいし一度わかったつもりでもまた時間を空けると忘れやすいので、ここをしっかりと押さえておく。以下に上記の整数範囲となる理由を書く。長いけどそれだけ理解には工程が必要。

コンピュータ内部の表現では非負の整数は通常の2進数で表現され、使用するビット長は8ビット，32ビットのように固定される。

例えば 25(10) という値は，8ビットで表現する場合、 00011001(2) となる。

8ビットで表現できる整数は，00000000(2) ～ 11111111(2) ，つまり 0 ～ 2^8 -1

同様にして、

16ビット使用して表現できる整数は，0 ～ 2^16 -1  
32ビット使用して表現できる整数は，0 ～ 2^32 -1

#### 2の補数

コンピュータ内部では2つの状態 0 と 1 しか使えないので - 記号を使うことはできない。そのため、負の数も 0、1 を使って表現する必要がある。

負の数の表現には2の補数を使用する。2の補数とは正の整数nに対して以下のように-nを定義するもの。ここで，数値を表現するビット数は16や32のように固定して考えることがポイント。

正の整数nを2進数で表す。ただし最上位のビットは0とすることがポイント。  
各ビットを反転する。（1→0，0→1）  
それに1を加える


例)  
整数は8ビットで表現するものとする。  
n = 18(10) とする。  
（まず8ビットの場合に、最初のビットが0となる値の範囲を確認する。 1(2) ≦ n ≦01111111(2)、つまり、 1 ≦ n ≦ 127（＝2^7-1））

n = 18(10)を8ビットの二進数で表現する。  
n = 00010010(2)  
各ビットを反転して，11101101  
これに 1 を加えて，11101110  
これが、-18(10) のを二進数で2の補数で表したものであり、内部表現。

n = 0 についても同様の変形をしてどうなるかを確認してみる。  
各ビットを反転して、11111111  
これに 1 を加えて、100000000  
8ビット固定なので、最上位ビットの1は保持されない。そのため、結果は00000000となり、0 = -0 が成り立つ。

以上から，次のような関係ができる。

| 元の数<br/>(10進数) | 元の数<br/>(二進数) | 2の補数<br/>(負の数) |
|:---: |:---: | :---: |
| 0 | 00000000 | 00000000 |
| 1 | 00000001 | 11111111 |
| 2 | 00000010 | 11111110 |
| : | : | : |
| 127 | 01111111 | 10000001 |
| 128 | 10000000 | 10000000 |


表の最下段の10000000は元の数と2の補数が同じ表現になっているため、元の数か負の数なのか見分けがつかない。  
+128 か -128 かどちらかに定めないといけない。負の数の最上位のビットはすべて1なので、10000000は負の数とした方が都合がよいので、-128 と定める。

10000000(2) = -2^7 = -128 と定める。以上で、8ビットで表せる最小値は-128となる。これは-2^7である。

10000000を-128と定めたので、最大値は128ではない。よって、自然と、8ビットで表せる最大値は128から1引いた127となる。以上から、

二進数8ビットで表せる十進数の整数の範囲は、-128 〜 127となる(-2^7 〜2^7-1)。

同様にして、16ビット、32ビットでも二進数の元の数と２の補数が同じになる。そのため、上記と同じ理由により、16ビットで表せる整数の範囲は-32768 〜 32767(-2^15 〜 2^15-1)となる。

### オーバーフローしないかの確認

ここまで理解できてようやく、問題に記載されている選択肢の条件がオーバーフローしないかどうかを確認できる。問題文では16ビットの符号付き整数なので、-2^15 〜 2^15-1、つまり-32768 〜 32767の整数にて選択肢の条件を検証する。

ア：整数x1、x2の絶対値を足したものが32768以下という条件  

16ビット符号付き整数で表現できる最大値は32767なので、たとえばx1 = 1, x2 = 32767の時はx1 + x2 = 32768となり、アの条件ではオーバーフローするのでアは間違い。

<br />

イ：x1とx2の絶対値がともに32767未満の場合

x1とx2の符号が同じ時にオーバーフローする場合がある。たとえば30000 + 10000。よってこれも間違い 

<br />

ウ：x1 * x2 > 0 の場合

x1とx2が同じ符号の時で、足した結果が32768を超えることはア及びイから明らかなのでこれも間違い。  
例えばx1 = -20000, x2 = -30000 の時x1 * x2 > 0、60000となりオーバーフローする。

<br />

エ：x1とx2の符号が異なる場合

符号が異なる場合、お互いに打ち消し合うので、必ず範囲内になり、オーバーフローしない。選択肢の消去法によってもわかるけど、感覚的にもこれだとわかり正解できる問題だったが、これまで書いた内容を復習し、エ以外の選択肢が間違っていることを厳密に検証できるようにしておきたい。






